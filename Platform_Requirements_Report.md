# 基盤機能要件定義書 (AIチャットボット・MVP版)

**作成日:** 2025/12/16 (最終更新: 2025/12/17)  
**対象:** AI翻訳機能付きチャットボット基盤

## 1. 概要
本プロジェクト（AIチャットボット）の初期リリースに向け、システムの根幹となる「必須機能（Must）」のみを選定・定義します。これらは、リアルタイム対話と翻訳・RAG機能を実現するために不可欠な要素です。

**技術スタック更新:** Spring WebFlux (Reactive Stack) を全面的に採用し、`springboot-starter` を機能別にモジュール分割しました。

---

## 2. 実装機能一覧 (必須項目のみ)

### 2.1 リアルタイム通信 (Real-time Communication)
*チャットボットの回答を「流れるように」表示するための基盤*

*   **WebSocket / SSE 基盤** (`starter-flux`)
    *   **役割:** サーバーからのプッシュ通知を実現する（Reactor Nettyベース）。
    *   **理由:** HTTPリクエストでは実現できない、ChatGPTのようなストリーミング表示に必須。
*   **STOMP プロトコル** (`starter-flux`)
    *   **役割:** メッセージの宛先（トピック）管理。
    *   **理由:** 「ユーザーAのチャットルーム」だけにメッセージを送る制御に必要。

### 2.2 会話管理 (Session Management)
*AIに「記憶」を持たせるための仕組み*

*   **Redis セッション管理** (`starter-flux`)
    *   **役割:** 会話履歴（Context）の保存。
    *   **理由:** 「前の質問なんだけど…」といった文脈依存の質問に答えるため。

### 2.3 AI / LLM連携 (AI Integration)
*大規模言語モデル（Brain）との接続*

*   **LLM クライアント** (`component`)
    *   **役割:** OpenAI / Azure OpenAI APIへの接続アダプタ。
    *   **理由:** モデルの切り替え（GPT-4 -> Claude等）が発生しても、アプリ側のコードを変えなくて済むようにする。
*   **プロンプト管理** (`component`)
    *   **役割:** システム指示（System Prompt）の注入。
    *   **理由:** 「あなたは親切な翻訳者です」といったキャラクター設定を統一管理する。

### 2.4 RAG (知識検索)
*社内文書や独自データに基づく回答*

*   **ドキュメント解析** (`component`)
    *   **役割:** PDF/Txtファイルのテキスト抽出。
    *   **理由:** ユーザーがアップロードした資料をAIが読める形式に変換するため。
*   **ベクトルストア接続** (`component`)
    *   **役割:** **pgvector** への接続と検索。
    *   **理由:** 膨大な資料の中から、質問に関連する箇所を瞬時に見つけ出すため。

### 2.5 翻訳機能 (Translation)
*多言語対応の要*

*   **自動言語検出** (`component`)
    *   **役割:** 入力テキストの言語判定（例: "こんにちは" -> `ja`）。
    *   **理由:** ユーザーの言語に合わせて、AIの返答言語を自動調整するため。

### 2.6 共通基盤 (Infrastructure)
*セキュリティと安定性*

*   **JWT認証フィルタ** (`starter-security`)
    *   **役割:** ユーザー認証（WebFlux WebFilter）。
    *   **理由:** 「誰がアクセスしているか」を特定し、他人のチャット履歴が見えないようにする。
*   **グローバル例外処理** (`component`)
    *   **役割:** エラーハンドリングの統一。
    *   **理由:** システムダウン時でも、ユーザーに「現在混み合っています」等の親切なメッセージを返すため。
*   **Kafka メッセージキュー** (`starter-flux`)
    *   **役割:** トラフィックの整流化。
    *   **理由:** 同時に1000人が話しかけてきても、サーバーがダウンしないようにリクエストを順番待ちさせる。

---

## 3. 開発ロードマップ（推奨）

1.  **Step 1: 通信と脳（Communication & Brain）**
    *   `starter-flux` に **WebSocket** 設定を追加し、ブラウザとのリアルタイム接続を確立する。
    *   `component` に **LLM Client** を作成し、単純な「ユーザー発言→AI応答」のループを作る。

2.  **Step 2: 記憶と知識（Memory & Knowledge）**
    *   **Redis** を導入し、会話のラリー（履歴）を保存できるようにする。
    *   **pgvector** と連携し、ドキュメントに基づいた回答（RAG）ができるようにする。

3.  **Step 3: スケール（Scale）**
    *   **Kafka** を間に挟み、リクエストを非同期処理化して安定性を確保する。
